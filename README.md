# TheCompiler 🚀

A comprehensive compiler implementation for a simplified Java-like programming language, built from scratch with lexical analysis, syntax parsing, semantic analysis, code generation, and virtual machine execution.

## 📋 Table of Contents

- [Overview](#overview)
- [Features](#features)
- [Architecture](#architecture)
- [Getting Started](#getting-started)
- [Language Specification](#language-specification)
- [Usage Examples](#usage-examples)
- [Project Structure](#project-structure)
- [Implementation Details](#implementation-details)
- [Testing](#testing)
- [Contributing](#contributing)
- [License](#license)

## 🔍 Overview

TheCompiler is a complete compiler implementation that demonstrates the full compilation pipeline from source code to executable bytecode. It includes:

- **Lexical Analyzer (Lexer)**: Tokenizes source code using DFA-based scanning
- **Syntax Analyzer (Parser)**: Recursive descent parser with error recovery
- **Semantic Analyzer**: Type checking, symbol table management, and semantic validation
- **Code Generator**: Produces intermediate code for a custom virtual machine
- **Virtual Machine**: Executes the generated bytecode with full debugging capabilities
- **Integrated IDE**: Complete development environment with real-time compilation and execution

## ✨ Features

### 🔧 Compiler Features
- **Multi-pass compilation** with complete error reporting
- **Robust error recovery** mechanisms in all phases
- **Symbol table management** with scope resolution
- **Type checking** using semantic cube methodology
- **Code optimization** for efficient bytecode generation

### 🎯 Language Support
- **Primitive data types**: `int`, `float`, `char`, `string`, `boolean`
- **Control structures**: `if/else`, `while`, `do-while`, `for`, `switch/case`
- **I/O operations**: `println()` for output, `inputln()` for input
- **Arithmetic and logical expressions** with proper precedence
- **Variable declarations and assignments**
- **Method definitions** with parameters and return types

### 🖥️ IDE Features
- **Integrated Development Environment** with tabbed interface
- **Real-time compilation** and execution
- **Step-by-step debugging** with virtual machine integration
- **Multiple views**: Lexer output, Parse tree, Symbol table, Intermediate code
- **Program execution** with input/output handling
- **Error highlighting** and recovery suggestions

## 🏗️ Architecture

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Source Code   │───▶│   TheLexer      │───▶│   TheParser     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                                        │
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  Virtual Machine│◀───│ TheCodeGenerator│◀───│  TheSemantic    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### Components

1. **TheLexer**: DFA-based tokenization with support for multiple number bases
2. **TheParser**: Recursive descent parser with FIRST/FOLLOW sets for error recovery
3. **TheSemantic**: Type checking and semantic validation using semantic cube
4. **TheCodeGenerator**: Intermediate code generation for stack-based VM
5. **Virtual Machine**: Custom VM with debugging capabilities and GUI
6. **CompilerUI**: Integrated development environment

## 🚀 Getting Started

### Prerequisites

- Java 22 or higher
- IntelliJ IDEA (recommended) or any Java IDE
- Git for version control

### Installation

1. **Clone the repository**
   ```bash
   git clone https://github.com/yourusername/TheCompiler.git
   cd TheCompiler
   ```

2. **Open in IntelliJ IDEA**
   - Open IntelliJ IDEA
   - Select "Open or Import"
   - Navigate to the cloned directory
   - Select the project folder

3. **Build and Run**
   ```bash
   # Compile the project
   javac -cp src src/main/java/javiergs/compiler/CompilerUI.java
   
   # Run the IDE
   java -cp src javiergs.compiler.CompilerUI
   ```

### Quick Start

1. **Launch the IDE** by running `CompilerUI.java`
2. **Write your program** in the source code editor
3. **Click "Compile & Run"** to execute your program
4. **View results** in the "Execution" tab

## 📝 Language Specification

### Data Types

```java
int x = 42;
float pi = 3.14159;
char letter = 'A';
string message = "Hello World";
boolean flag = true;
```

### Control Structures

```java
// If-else statement
if (x > 0) {
    println("Positive");
} else {
    println("Non-positive");
}

// While loop
while (x > 0) {
    println(x);
    x = x - 1;
}

// For loop
for (int i = 0; i < 10; i = i + 1) {
    println(i);
}

// Switch statement
switch (x) {
    case 1:
        println("One");
        break;
    case 2:
        println("Two");
        break;
    default:
        println("Other");
}
```

### Input/Output

```java
// Output
println("Enter a number:");
println(42);

// Input
int number = inputln();
```

### Supported Operators

- **Arithmetic**: `+`, `-`, `*`, `/`
- **Comparison**: `>`, `<`, `==`, `!=`, `>=`, `<=`
- **Logical**: `&&`, `||`, `!`
- **Assignment**: `=`

## 💡 Usage Examples

### Example 1: Basic Calculator
```java
{
    int a, b, result;
    
    println("Enter first number:");
    a = inputln();
    
    println("Enter second number:");
    b = inputln();
    
    result = a + b;
    println("Sum is:");
    println(result);
}
```

### Example 2: Factorial Calculation
```java
{
    int n, factorial, i;
    
    println("Enter a number:");
    n = inputln();
    
    factorial = 1;
    for (i = 1; i <= n; i = i + 1) {
        factorial = factorial * i;
    }
    
    println("Factorial is:");
    println(factorial);
}
```

### Example 3: Number Guessing Game
```java
{
    int secret, guess;
    secret = 42;
    
    println("Guess the number (1-100):");
    guess = inputln();
    
    if (guess == secret) {
        println("Congratulations! You got it!");
    } else if (guess < secret) {
        println("Too low!");
    } else {
        println("Too high!");
    }
}
```

## 📁 Project Structure

```
TheCompiler/
├── src/
│   ├── main/
│   │   ├── java/javiergs/
│   │   │   ├── compiler/
│   │   │   │   ├── CompilerUI.java           # Main IDE interface
│   │   │   │   ├── TheLexer.java             # Lexical analyzer
│   │   │   │   ├── TheParser.java            # Syntax analyzer
│   │   │   │   ├── TheSemantic.java          # Semantic analyzer
│   │   │   │   ├── TheCodeGenerator.java     # Code generator
│   │   │   │   ├── TheToken.java             # Token representation
│   │   │   │   ├── TheMain.java              # CLI interface
│   │   │   │   ├── Automata.java             # DFA implementation
│   │   │   │   └── ProgrammaticInterpreter.java # Headless VM
│   │   │   └── vm/
│   │   │       ├── Interpreter.java          # Virtual machine with GUI
│   │   │       ├── InterpreterUI.java        # VM user interface
│   │   │       ├── Instruction.java          # VM instruction class
│   │   │       └── Symbol.java               # Symbol table entry
│   │   └── resources/
│   │       ├── input*.txt                    # Test files
│   │       └── firstfollow/
│   │           └── firstfollow.md            # Grammar analysis
│   └── test/
│       ├── java/
│       │   └── TestTheParser.java            # Parser tests
│       └── resources/
│           ├── *.txt                         # Test cases
│           └── TestResults.md                # Test documentation
├── README.md
└── Semantic Analysis.pdf                     # Documentation
```

## 🔧 Implementation Details

### Lexical Analysis
- **DFA-based tokenization** with support for multiple number formats
- **Error recovery** for invalid tokens
- **Support for**: Binary (0b), Octal (0), Decimal, Hexadecimal (0x), Float with exponents

### Syntax Analysis
- **Recursive descent parser** with grammar-based rules
- **FIRST/FOLLOW sets** for predictive parsing
- **Error recovery** mechanisms to continue parsing after errors
- **Parse tree generation** for visualization

### Semantic Analysis
- **Symbol table** with scope management
- **Type checking** using semantic cube methodology
- **Declaration and usage validation**
- **Method signature verification**

### Code Generation
- **Stack-based intermediate code** generation
- **Label resolution** for control structures
- **Optimization** for common patterns
- **VM-compatible instruction set**

### Virtual Machine
- **Stack-based execution model**
- **Instruction set**: Load, Store, Operations, Jumps, I/O
- **Debugging support** with step-by-step execution
- **Memory management** with symbol table integration

## 🧪 Testing

### Running Tests

```bash
# Run parser tests
java -cp src javiergs.compiler.TestTheParser

# Test individual files
java -cp src javiergs.compiler.TheMain
```

### Test Cases

The project includes comprehensive test cases covering:

- **Lexical analysis**: All token types and edge cases
- **Syntax analysis**: Valid and invalid programs with error recovery
- **Semantic analysis**: Type checking and scope resolution
- **Code generation**: Correct intermediate code for all constructs
- **Virtual machine**: Execution correctness and debugging

### Error Handling Tests

- **Syntax errors**: Missing semicolons, braces, parentheses
- **Semantic errors**: Type mismatches, undeclared variables
- **Runtime errors**: Division by zero, stack underflow

## 🎯 Key Features Demonstration

### Real-time Compilation
The IDE shows all compilation phases simultaneously:
- **Lexer tab**: Token stream with line numbers
- **Parser tab**: Parse tree visualization
- **Semantic tab**: Symbol table with types and scopes
- **Intermediate Code tab**: Generated VM instructions
- **Execution tab**: Program output and execution log

### Error Recovery
The compiler continues processing even after errors:
```java
{
    int x = 5
    // Missing semicolon - compiler recovers and continues
    println(x);
}
```

### Interactive Input/Output
```java
{
    println("What's your name?");
    string name = inputln();
    println("Hello " + name);
}
```

## 🤝 Contributing

We welcome contributions! Please follow these guidelines:

1. **Fork the repository**
2. **Create a feature branch** (`git checkout -b feature/amazing-feature`)
3. **Commit your changes** (`git commit -m 'Add amazing feature'`)
4. **Push to the branch** (`git push origin feature/amazing-feature`)
5. **Open a Pull Request**

### Development Guidelines

- Follow Java naming conventions
- Add comprehensive comments for new features
- Include test cases for new functionality
- Update documentation as needed

## 📄 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## 👥 Authors

- **javiergs** - *Initial work and architecture*
- **eduardomv** - *Semantic analysis and code generation*
- **santiarr** - *Parser implementation and error recovery*
- **yawham** - *Virtual machine and debugging features*

## 🙏 Acknowledgments

- Inspired by classical compiler design principles
- Built for educational purposes in compiler construction
- Special thanks to the CSE340 Virtual Machine architecture

## 📚 Additional Resources

- [Compiler Design Principles](doc/compiler-principles.md)
- [Grammar Specification](src/main/firstfollow/firstfollow.md)
- [VM Instruction Set](doc/vm-instructions.md)
- [Testing Documentation](src/test/resources/TestResults.md)

---

**Happy Compiling!** 🎉

For questions or support, please open an issue in the GitHub repository.
